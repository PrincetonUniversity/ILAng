<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ilang: ilang Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ilang
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">ILAng: A Modeling and Verification Platform for SoCs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ilang Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_abs_knob.html">AbsKnob</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_ast.html">Ast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for the Abstract Syntax Tree. An <a class="el" href="classilang_1_1_ast.html" title="The class for the Abstract Syntax Tree. An Ast object can be an expression or function definition (in...">Ast</a> object can be an expression or function definition (interpreted or uninterpreted).  <a href="classilang_1_1_ast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_bool_val.html">BoolVal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container for representing Boolean values.  <a href="classilang_1_1_bool_val.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_bv_val.html">BvVal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container for representing Bitvector values.  <a href="classilang_1_1_bv_val.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_comm_diag.html">CommDiag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generator for commutating diagram-based equivalence checking.  <a href="classilang_1_1_comm_diag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_comp_ref_rel.html">CompRefRel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compositional refinement relation defines a unit (element for the composition) of refinement relation, which specifies.  <a href="classilang_1_1_comp_ref_rel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_debug_log.html">DebugLog</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for enabling and disabling debug tags.  <a href="classilang_1_1_debug_log.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr.html">Expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for expression, which is the basic type for variables, constraints, state update expressions, etc.  <a href="classilang_1_1_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_const.html">ExprConst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression for constant values (bool, bv, or memory). Constant should be terminating nodes in the AST.  <a href="classilang_1_1_expr_const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_hash.html">ExprHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function object for hashing <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a>. The hash value is the id of the symbol, which is supposed to be unique.  <a href="classilang_1_1_expr_hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_mngr.html">ExprMngr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifier for AST trees by sharing nodes based on the hash value.  <a href="classilang_1_1_expr_mngr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op.html">ExprOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression for operations, e.g. AND, OR, ADD, etc. Operations are non-terminating nodes in the AST.  <a href="classilang_1_1_expr_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_add.html">ExprOpAdd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for unsigned addition.  <a href="classilang_1_1_expr_op_add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_and.html">ExprOpAnd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for binary logical AND operation "&amp;".  <a href="classilang_1_1_expr_op_and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_app_func.html">ExprOpAppFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for apply uninterpreted function.  <a href="classilang_1_1_expr_op_app_func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_ashr.html">ExprOpAshr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for arithmetic right shifting a bit-vector.  <a href="classilang_1_1_expr_op_ashr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_compl.html">ExprOpCompl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for unary bit-wise complement "~". (bv only)  <a href="classilang_1_1_expr_op_compl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_concat.html">ExprOpConcat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for bitvector concatenation.  <a href="classilang_1_1_expr_op_concat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_eq.html">ExprOpEq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for binary comparison EQ "==".  <a href="classilang_1_1_expr_op_eq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_extract.html">ExprOpExtract</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for bitvector extraction.  <a href="classilang_1_1_expr_op_extract.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_gt.html">ExprOpGt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for binary comparison signed greater than "&gt;".  <a href="classilang_1_1_expr_op_gt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_imply.html">ExprOpImply</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for logical imply.  <a href="classilang_1_1_expr_op_imply.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_ite.html">ExprOpIte</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for if-then-else.  <a href="classilang_1_1_expr_op_ite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_load.html">ExprOpLoad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for memory load.  <a href="classilang_1_1_expr_op_load.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_lshr.html">ExprOpLshr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for logical right shifting a bit-vector.  <a href="classilang_1_1_expr_op_lshr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_lt.html">ExprOpLt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for binary comparison signed less than "&lt;".  <a href="classilang_1_1_expr_op_lt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_neg.html">ExprOpNeg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for unary negate operation "-".  <a href="classilang_1_1_expr_op_neg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_not.html">ExprOpNot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for unary not operation "!". (bool only)  <a href="classilang_1_1_expr_op_not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_or.html">ExprOpOr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for binary logical OR operation "|".  <a href="classilang_1_1_expr_op_or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_s_ext.html">ExprOpSExt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The calss wrapper for sign-extend.  <a href="classilang_1_1_expr_op_s_ext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_shl.html">ExprOpShl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for left shifting a bit-vector.  <a href="classilang_1_1_expr_op_shl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_store.html">ExprOpStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for memory store.  <a href="classilang_1_1_expr_op_store.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_sub.html">ExprOpSub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for unsigned subtraction.  <a href="classilang_1_1_expr_op_sub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_ugt.html">ExprOpUgt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for binary comparison unsigned greater than.  <a href="classilang_1_1_expr_op_ugt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_ult.html">ExprOpUlt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for binary comparison unsigned less than.  <a href="classilang_1_1_expr_op_ult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_xor.html">ExprOpXor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper for binary logical XOR operation "^".  <a href="classilang_1_1_expr_op_xor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_op_z_ext.html">ExprOpZExt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wrapper for zero-extend.  <a href="classilang_1_1_expr_op_z_ext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper of <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a> (e.g. state var, var relation, constant, etc).  <a href="classilang_1_1_expr_ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_expr_var.html">ExprVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression for variables (bool, bv, or mem). Variable should be the terminating nodes in the AST.  <a href="classilang_1_1_expr_var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_func.html">Func</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for uninterpreted function.  <a href="classilang_1_1_func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_func_obj_flat_ila.html">FuncObjFlatIla</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for flatten ILA tree. There is currently a problem: this func obj calls duplInst which in turn uses rewriteExpr and rewriteExpr does not change the host of of state variables, so the flatten expression still has the host pointed to their original ILA. This is fine for Verilog Gen, which only depends on variable names to generate variables but may not be good enough for other purpose.  <a href="classilang_1_1_func_obj_flat_ila.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_func_obj_rewr_expr.html">FuncObjRewrExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for rewriting <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a>.  <a href="classilang_1_1_func_obj_rewr_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_func_obj_rewr_ila.html">FuncObjRewrIla</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for rewriting ILA tree.  <a href="classilang_1_1_func_obj_rewr_ila.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_func_ref.html">FuncRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper of <a class="el" href="classilang_1_1_func.html" title="The class for uninterpreted function.">Func</a> (uninterpreted function).  <a href="classilang_1_1_func_ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_host_remove_restore.html">HostRemoveRestore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to remove and restore the host info This is useful as we want the ast with the same name generates the same z3 expr. This framework is based on an assumption that if we call z3 to create the variable of the same name multiple times they refer to the same one internally. FIXME: Need to check this assumption if we want to support other SMT solvers!  <a href="classilang_1_1_host_remove_restore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_ila.html">Ila</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper of <a class="el" href="classilang_1_1_instr_lvl_abs.html" title="The class of Instruction-Level Abstraction (ILA). An ILA contains:">InstrLvlAbs</a> (ILA).  <a href="classilang_1_1_ila.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_ila_z3_unroller.html">IlaZ3Unroller</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper of generating z3::expr for verification.  <a href="classilang_1_1_ila_z3_unroller.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_instr.html">Instr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for the Instruction. An <a class="el" href="classilang_1_1_instr.html" title="The class for the Instruction. An Instr object contains:">Instr</a> object contains:  <a href="classilang_1_1_instr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_instr_lvl_abs.html">InstrLvlAbs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class of Instruction-Level Abstraction (ILA). An ILA contains:  <a href="classilang_1_1_instr_lvl_abs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_instr_ref.html">InstrRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper of <a class="el" href="classilang_1_1_instr.html" title="The class for the Instruction. An Instr object contains:">Instr</a> (instruction).  <a href="classilang_1_1_instr_ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_instr_seq.html">InstrSeq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruction Sequencing does:  <a href="classilang_1_1_instr_seq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_instr_tran_edge.html">InstrTranEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruction transition edge, includeing:  <a href="classilang_1_1_instr_tran_edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_instr_tran_node.html">InstrTranNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node for instruction-transition node, each node represent an instruction.  <a href="classilang_1_1_instr_tran_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_inter_ila_unroller.html">InterIlaUnroller</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for unrolling multiple ILAs. There are two ways of unrolling: ordered and unordered. Ordered unrolling assumes an ordered program template, despite that some may not exist in the final outcome. By default the state with the same name among ILAs is considered as the same shared state.  <a href="classilang_1_1_inter_ila_unroller.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_key_vec.html">KeyVec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container that support key search and index access.  <a href="classilang_1_1_key_vec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_key_vec_it.html">KeyVecIt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pseudo-iterator for the key-search vector.  <a href="classilang_1_1_key_vec_it.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_legacy_bmc.html">LegacyBmc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified bounded model checking engine for ILAs.  <a href="classilang_1_1_legacy_bmc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_log_initter.html">LogInitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A one-time class for initializing GLog.  <a href="classilang_1_1_log_initter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_map_set.html">MapSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map for sets.  <a href="classilang_1_1_map_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_memory_model.html">MemoryModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for memory models.  <a href="classilang_1_1_memory_model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_mem_val.html">MemVal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container for representing memory (array) values.  <a href="classilang_1_1_mem_val.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_mono_unroll.html">MonoUnroll</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Application class for unrolling the ILA as a monolithic transition system.  <a href="classilang_1_1_mono_unroll.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_nested_mem_addr_data_avoider.html">NestedMemAddrDataAvoider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of traversing to avoid nested memory access in address.  <a href="classilang_1_1_nested_mem_addr_data_avoider.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_object.html">Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The basest type in the ILA structure. It can be either <a class="el" href="classilang_1_1_ast.html" title="The class for the Abstract Syntax Tree. An Ast object can be an expression or function definition (in...">Ast</a>, <a class="el" href="classilang_1_1_instr.html" title="The class for the Instruction. An Instr object contains:">Instr</a>, or <a class="el" href="classilang_1_1_instr_lvl_abs.html" title="The class of Instruction-Level Abstraction (ILA). An ILA contains:">InstrLvlAbs</a>.  <a href="classilang_1_1_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_path_unroll.html">PathUnroll</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Application class for unrolling a path of instruction sequence.  <a href="classilang_1_1_path_unroll.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_refinement_map.html">RefinementMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refinement mapping defines how to map micro-architectural states to architectural states for comparison.  <a href="classilang_1_1_refinement_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_relation_map.html">RelationMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relation mapping defines how arch states of two models are mapped, i.e., state mapping.  <a href="classilang_1_1_relation_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_sc.html">Sc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of TSO.  <a href="classilang_1_1_sc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_sc_trace_step.html">ScTraceStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of TSO trace step.  <a href="classilang_1_1_sc_trace_step.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_sort.html">Sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for sort (type for expr, and the range/domain of functions).  <a href="classilang_1_1_sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_sort_bool.html">SortBool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class of Boolean <a class="el" href="classilang_1_1_sort.html" title="The class for sort (type for expr, and the range/domain of functions).">Sort</a>.  <a href="classilang_1_1_sort_bool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_sort_bv.html">SortBv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class of bit-vector <a class="el" href="classilang_1_1_sort.html" title="The class for sort (type for expr, and the range/domain of functions).">Sort</a>.  <a href="classilang_1_1_sort_bv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_sort_mem.html">SortMem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class of memory (array) <a class="el" href="classilang_1_1_sort.html" title="The class for sort (type for expr, and the range/domain of functions).">Sort</a>.  <a href="classilang_1_1_sort_mem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_sort_ref.html">SortRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper of <a class="el" href="classilang_1_1_sort.html" title="The class for sort (type for expr, and the range/domain of functions).">Sort</a> (type for different AST nodes).  <a href="classilang_1_1_sort_ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_symbol.html">Symbol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The symbol is the name and ID of an object. Every object has an unique symbol.  <a href="classilang_1_1_symbol.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_syn_eng_mngr.html">SynEngMngr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for interfacing templated-based synthesis engine.  <a href="classilang_1_1_syn_eng_mngr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_trace_step.html">TraceStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for trace step (an instance of instruction) As in the unrolling, there may be multiple instances of the same instructions, so we have the trace steps.  <a href="classilang_1_1_trace_step.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_tso.html">Tso</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of TSO.  <a href="classilang_1_1_tso.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_tso_trace_step.html">TsoTraceStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of TSO trace step.  <a href="classilang_1_1_tso_trace_step.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_unroller.html">Unroller</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for unrolling ILA execution in different settings.  <a href="classilang_1_1_unroller.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_value.html">Value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base type for constant value.  <a href="classilang_1_1_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_var_use_finder.html">VarUseFinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of finding variable uses. So that we don't need to create pi variables for unused state variables. FIXME: currently there is no need to make a class for it, but in the future it is possible to use a hash table to avoid traverse the same sub-tree twice.  <a href="classilang_1_1_var_use_finder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_verilog_generator.html">VerilogGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of Verilog Generator.  <a href="classilang_1_1_verilog_generator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classilang_1_1_z3_expr_adapter.html">Z3ExprAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for generating z3 expression from an ILA.  <a href="classilang_1_1_z3_expr_adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7c4196c72e53ea4df4b7861af7bc3bce"><td class="memItemLeft" align="right" valign="top"><a id="a7c4196c72e53ea4df4b7861af7bc3bce"></a>
typedef <a class="el" href="classilang_1_1_expr.html#a85952b6a34620c4c8cab6bac9c9fdf8c">Expr::ExprPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a></td></tr>
<tr class="memdesc:a7c4196c72e53ea4df4b7861af7bc3bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for normal use of <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a>. <br /></td></tr>
<tr class="separator:a7c4196c72e53ea4df4b7861af7bc3bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d222bcc4d46261cbf6dbc18a3f5e11"><td class="memItemLeft" align="right" valign="top"><a id="a95d222bcc4d46261cbf6dbc18a3f5e11"></a>
typedef <a class="el" href="classilang_1_1_expr.html#a17efc8282f647681d37cd4c78928aa01">Expr::ExprPtrVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a95d222bcc4d46261cbf6dbc18a3f5e11">ExprPtrVec</a></td></tr>
<tr class="memdesc:a95d222bcc4d46261cbf6dbc18a3f5e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for storing a set of <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a>. <br /></td></tr>
<tr class="separator:a95d222bcc4d46261cbf6dbc18a3f5e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40e6475e04844bcad9c380aac0b215c"><td class="memItemLeft" align="right" valign="top"><a id="ad40e6475e04844bcad9c380aac0b215c"></a>
typedef std::unordered_map&lt; const <a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a>, const <a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a>, <a class="el" href="classilang_1_1_expr_hash.html">ExprHash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad40e6475e04844bcad9c380aac0b215c">ExprMap</a></td></tr>
<tr class="memdesc:ad40e6475e04844bcad9c380aac0b215c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for mapping between <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a>. <br /></td></tr>
<tr class="separator:ad40e6475e04844bcad9c380aac0b215c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54732171848dbcb975458e689024a04c"><td class="memItemLeft" align="right" valign="top"><a id="a54732171848dbcb975458e689024a04c"></a>
typedef std::unordered_set&lt; <a class="el" href="namespaceilang.html#a7c4196c72e53ea4df4b7861af7bc3bce">ExprPtr</a>, <a class="el" href="classilang_1_1_expr_hash.html">ExprHash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a54732171848dbcb975458e689024a04c">ExprSet</a></td></tr>
<tr class="memdesc:a54732171848dbcb975458e689024a04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for storing a set of <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a>. <br /></td></tr>
<tr class="separator:a54732171848dbcb975458e689024a04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6140a3823254564a0e81db8b3afea25c"><td class="memItemLeft" align="right" valign="top"><a id="a6140a3823254564a0e81db8b3afea25c"></a>
typedef <a class="el" href="classilang_1_1_func.html#a91aa192ceb8b9025423fdb95c8429282">Func::FuncPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a6140a3823254564a0e81db8b3afea25c">FuncPtr</a></td></tr>
<tr class="memdesc:a6140a3823254564a0e81db8b3afea25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for normal use of <a class="el" href="classilang_1_1_func.html" title="The class for uninterpreted function.">Func</a>. <br /></td></tr>
<tr class="separator:a6140a3823254564a0e81db8b3afea25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01073336878d60a231f4fe96d45ab55"><td class="memItemLeft" align="right" valign="top"><a id="ae01073336878d60a231f4fe96d45ab55"></a>
typedef <a class="el" href="classilang_1_1_sort.html#a8b9cc5e381404211a1c0423327866d3b">Sort::SortPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ae01073336878d60a231f4fe96d45ab55">SortPtr</a></td></tr>
<tr class="memdesc:ae01073336878d60a231f4fe96d45ab55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for storing/passing <a class="el" href="classilang_1_1_sort.html" title="The class for sort (type for expr, and the range/domain of functions).">Sort</a>. <br /></td></tr>
<tr class="separator:ae01073336878d60a231f4fe96d45ab55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad512edf5ea3912c37cb9c9a4a47d09d0"><td class="memItemLeft" align="right" valign="top"><a id="ad512edf5ea3912c37cb9c9a4a47d09d0"></a>
typedef <a class="el" href="classilang_1_1_value.html#af7f5423825f03fdb5f62d2598778d644">Value::ValPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad512edf5ea3912c37cb9c9a4a47d09d0">ValPtr</a></td></tr>
<tr class="memdesc:ad512edf5ea3912c37cb9c9a4a47d09d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for all use of <a class="el" href="classilang_1_1_value.html" title="The base type for constant value.">Value</a>. <br /></td></tr>
<tr class="separator:ad512edf5ea3912c37cb9c9a4a47d09d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dabeb8fdac011892c311e074696b570"><td class="memItemLeft" align="right" valign="top"><a id="a8dabeb8fdac011892c311e074696b570"></a>
typedef <a class="el" href="classilang_1_1_bool_val.html#aba4dff009d7d7f6c0a879312dbb23ba3">BoolVal::BoolValPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a8dabeb8fdac011892c311e074696b570">BoolValPtr</a></td></tr>
<tr class="memdesc:a8dabeb8fdac011892c311e074696b570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for all use of <a class="el" href="classilang_1_1_bool_val.html" title="The container for representing Boolean values.">BoolVal</a>. <br /></td></tr>
<tr class="separator:a8dabeb8fdac011892c311e074696b570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b38d4e87534db4ff8b793d11d1d950"><td class="memItemLeft" align="right" valign="top"><a id="af9b38d4e87534db4ff8b793d11d1d950"></a>
typedef <a class="el" href="classilang_1_1_bv_val.html#a880f2d0a32113b4cc4f5faa05e3c3b4a">BvVal::BvValType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#af9b38d4e87534db4ff8b793d11d1d950">BvValType</a></td></tr>
<tr class="memdesc:af9b38d4e87534db4ff8b793d11d1d950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for storing <a class="el" href="classilang_1_1_bv_val.html" title="The container for representing Bitvector values.">BvVal</a>. <br /></td></tr>
<tr class="separator:af9b38d4e87534db4ff8b793d11d1d950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a892f6286748cb7548429984d840752"><td class="memItemLeft" align="right" valign="top"><a id="a6a892f6286748cb7548429984d840752"></a>
typedef <a class="el" href="classilang_1_1_bv_val.html#a07cd315cb7e6d40ec7fef2b00989b074">BvVal::BvValPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a6a892f6286748cb7548429984d840752">BvValPtr</a></td></tr>
<tr class="memdesc:a6a892f6286748cb7548429984d840752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for all use of <a class="el" href="classilang_1_1_bv_val.html" title="The container for representing Bitvector values.">BvVal</a>. <br /></td></tr>
<tr class="separator:a6a892f6286748cb7548429984d840752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd677b2cf7cb4e83a1e81f35e9aec6b"><td class="memItemLeft" align="right" valign="top"><a id="a4fd677b2cf7cb4e83a1e81f35e9aec6b"></a>
typedef <a class="el" href="classilang_1_1_mem_val.html#a9a2bf21ab1aa0d15fcb9024025a1487e">MemVal::MemValPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4fd677b2cf7cb4e83a1e81f35e9aec6b">MemValPtr</a></td></tr>
<tr class="memdesc:a4fd677b2cf7cb4e83a1e81f35e9aec6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for all use of <a class="el" href="classilang_1_1_mem_val.html" title="The container for representing memory (array) values.">MemVal</a>. <br /></td></tr>
<tr class="separator:a4fd677b2cf7cb4e83a1e81f35e9aec6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63554514c4dc658062d446051c78882"><td class="memItemLeft" align="right" valign="top"><a id="aa63554514c4dc658062d446051c78882"></a>
typedef <a class="el" href="classilang_1_1_mem_val.html#aea3cddbc760f2e143d02cdfab66e6b36">MemVal::MemValMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aa63554514c4dc658062d446051c78882">MemValMap</a></td></tr>
<tr class="memdesc:aa63554514c4dc658062d446051c78882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for storing the address/data mapping. <br /></td></tr>
<tr class="separator:aa63554514c4dc658062d446051c78882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540a114dcaa252083440129309151528"><td class="memItemLeft" align="right" valign="top"><a id="a540a114dcaa252083440129309151528"></a>
typedef <a class="el" href="classilang_1_1_refinement_map.html#ab988c650cef076c777dd0200e8dab51f">RefinementMap::RefPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a540a114dcaa252083440129309151528">RefPtr</a></td></tr>
<tr class="memdesc:a540a114dcaa252083440129309151528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for passing around the refinement mapping. <br /></td></tr>
<tr class="separator:a540a114dcaa252083440129309151528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca57fadf3c1f00dba124eb1ec56e6e9"><td class="memItemLeft" align="right" valign="top"><a id="adca57fadf3c1f00dba124eb1ec56e6e9"></a>
typedef <a class="el" href="classilang_1_1_relation_map.html#adfdefb173e77fc29073c233aa3ccdbd2">RelationMap::RelPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#adca57fadf3c1f00dba124eb1ec56e6e9">RelPtr</a></td></tr>
<tr class="memdesc:adca57fadf3c1f00dba124eb1ec56e6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for passing around the relation mapping. <br /></td></tr>
<tr class="separator:adca57fadf3c1f00dba124eb1ec56e6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2c096b87ad7a9475c5a32315c18ba6"><td class="memItemLeft" align="right" valign="top"><a id="a3c2c096b87ad7a9475c5a32315c18ba6"></a>
typedef <a class="el" href="classilang_1_1_comp_ref_rel.html#a9081b437a14b3a2edef9d30b000ea535">CompRefRel::CrrPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a3c2c096b87ad7a9475c5a32315c18ba6">CrrPtr</a></td></tr>
<tr class="memdesc:a3c2c096b87ad7a9475c5a32315c18ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for passing around the compositional relation mapping. <br /></td></tr>
<tr class="separator:a3c2c096b87ad7a9475c5a32315c18ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4eee919aa24fff882d03a48d733c19"><td class="memItemLeft" align="right" valign="top"><a id="adc4eee919aa24fff882d03a48d733c19"></a>
typedef std::vector&lt; z3::expr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#adc4eee919aa24fff882d03a48d733c19">Z3ExprVec</a></td></tr>
<tr class="memdesc:adc4eee919aa24fff882d03a48d733c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector type for z3 expression. <br /></td></tr>
<tr class="separator:adc4eee919aa24fff882d03a48d733c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9ddf66d424d9d9544db761963a5836"><td class="memItemLeft" align="right" valign="top"><a id="aca9ddf66d424d9d9544db761963a5836"></a>
typedef std::shared_ptr&lt; <a class="el" href="namespaceilang.html#adc4eee919aa24fff882d03a48d733c19">Z3ExprVec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aca9ddf66d424d9d9544db761963a5836">Z3ExprVecPtr</a></td></tr>
<tr class="memdesc:aca9ddf66d424d9d9544db761963a5836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer for the z3 expression vector. <br /></td></tr>
<tr class="separator:aca9ddf66d424d9d9544db761963a5836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e34b145b7ce30f509c336c32013c097"><td class="memItemLeft" align="right" valign="top"><a id="a9e34b145b7ce30f509c336c32013c097"></a>
typedef <a class="el" href="classilang_1_1_key_vec.html">KeyVec</a>&lt; <a class="el" href="classilang_1_1_symbol.html">Symbol</a>, z3::expr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a9e34b145b7ce30f509c336c32013c097">Z3ExprMap</a></td></tr>
<tr class="memdesc:a9e34b145b7ce30f509c336c32013c097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map type for z3 expression. <br /></td></tr>
<tr class="separator:a9e34b145b7ce30f509c336c32013c097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96aa5111edd013874f3cfd7de9bf11bc"><td class="memItemLeft" align="right" valign="top"><a id="a96aa5111edd013874f3cfd7de9bf11bc"></a>
typedef std::shared_ptr&lt; <a class="el" href="namespaceilang.html#a9e34b145b7ce30f509c336c32013c097">Z3ExprMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a96aa5111edd013874f3cfd7de9bf11bc">Z3ExprMapPtr</a></td></tr>
<tr class="memdesc:a96aa5111edd013874f3cfd7de9bf11bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer for the z3 expression map. <br /></td></tr>
<tr class="separator:a96aa5111edd013874f3cfd7de9bf11bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee5051111191e26d672ae214bcf3e1b"><td class="memItemLeft" align="right" valign="top"><a id="a4ee5051111191e26d672ae214bcf3e1b"></a>
typedef <a class="el" href="classilang_1_1_expr_mngr.html#ad35ebf0cecad6f10877667b766bdfac1">ExprMngr::ExprMngrPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4ee5051111191e26d672ae214bcf3e1b">ExprMngrPtr</a></td></tr>
<tr class="memdesc:a4ee5051111191e26d672ae214bcf3e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for passing shared ast simplifier. <br /></td></tr>
<tr class="separator:a4ee5051111191e26d672ae214bcf3e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88a19312ae653d687a0d1207bb284f6"><td class="memItemLeft" align="right" valign="top"><a id="af88a19312ae653d687a0d1207bb284f6"></a>
typedef <a class="el" href="classilang_1_1_instr.html#af43ebb1fe223b369e42b5600f902b4b4">Instr::InstrPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#af88a19312ae653d687a0d1207bb284f6">InstrPtr</a></td></tr>
<tr class="memdesc:af88a19312ae653d687a0d1207bb284f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for normal use of <a class="el" href="classilang_1_1_instr.html" title="The class for the Instruction. An Instr object contains:">Instr</a>. <br /></td></tr>
<tr class="separator:af88a19312ae653d687a0d1207bb284f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13249a9b1d22eb3454730a7903be4364"><td class="memItemLeft" align="right" valign="top"><a id="a13249a9b1d22eb3454730a7903be4364"></a>
typedef std::shared_ptr&lt; const <a class="el" href="classilang_1_1_instr.html">Instr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a13249a9b1d22eb3454730a7903be4364">InstrCnstPtr</a></td></tr>
<tr class="memdesc:a13249a9b1d22eb3454730a7903be4364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for read-only use of <a class="el" href="classilang_1_1_instr.html" title="The class for the Instruction. An Instr object contains:">Instr</a>. <br /></td></tr>
<tr class="separator:a13249a9b1d22eb3454730a7903be4364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e6555f156373812f16030b98c42e65"><td class="memItemLeft" align="right" valign="top"><a id="a35e6555f156373812f16030b98c42e65"></a>
typedef std::vector&lt; <a class="el" href="namespaceilang.html#af88a19312ae653d687a0d1207bb284f6">InstrPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a35e6555f156373812f16030b98c42e65">InstrVec</a></td></tr>
<tr class="memdesc:a35e6555f156373812f16030b98c42e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for storing a set of <a class="el" href="classilang_1_1_instr.html" title="The class for the Instruction. An Instr object contains:">Instr</a>. <br /></td></tr>
<tr class="separator:a35e6555f156373812f16030b98c42e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b30fdf347e493b3937143da05d1a72"><td class="memItemLeft" align="right" valign="top"><a id="ad1b30fdf347e493b3937143da05d1a72"></a>
typedef <a class="el" href="classilang_1_1_instr_lvl_abs.html#a743fd98e5ad145d70cb0dabf8db0007c">InstrLvlAbs::InstrLvlAbsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a></td></tr>
<tr class="memdesc:ad1b30fdf347e493b3937143da05d1a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for normal use of <a class="el" href="classilang_1_1_instr_lvl_abs.html" title="The class of Instruction-Level Abstraction (ILA). An ILA contains:">InstrLvlAbs</a>. <br /></td></tr>
<tr class="separator:ad1b30fdf347e493b3937143da05d1a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc86156b73aa1a4b6369645e9b96ff19"><td class="memItemLeft" align="right" valign="top"><a id="adc86156b73aa1a4b6369645e9b96ff19"></a>
typedef <a class="el" href="classilang_1_1_instr_lvl_abs.html#a57464e2e6a69327715fa88963ebfb282">InstrLvlAbs::InstrLvlAbsCnstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#adc86156b73aa1a4b6369645e9b96ff19">InstrLvlAbsCnstPtr</a></td></tr>
<tr class="memdesc:adc86156b73aa1a4b6369645e9b96ff19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for read-only usage of <a class="el" href="classilang_1_1_instr_lvl_abs.html" title="The class of Instruction-Level Abstraction (ILA). An ILA contains:">InstrLvlAbs</a>. <br /></td></tr>
<tr class="separator:adc86156b73aa1a4b6369645e9b96ff19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e780d7b16cb21d2c10f955c504e7356"><td class="memItemLeft" align="right" valign="top"><a id="a4e780d7b16cb21d2c10f955c504e7356"></a>
typedef std::map&lt; <a class="el" href="namespaceilang.html#adc86156b73aa1a4b6369645e9b96ff19">InstrLvlAbsCnstPtr</a>, <a class="el" href="namespaceilang.html#ad1b30fdf347e493b3937143da05d1a72">InstrLvlAbsPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4e780d7b16cb21d2c10f955c504e7356">CnstIlaMap</a></td></tr>
<tr class="memdesc:a4e780d7b16cb21d2c10f955c504e7356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for storing a mapping from constant ILA ptr to ILA ptr. <br /></td></tr>
<tr class="separator:a4e780d7b16cb21d2c10f955c504e7356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc547f597d2a58cf82dfe756fe092d86"><td class="memItemLeft" align="right" valign="top"><a id="adc547f597d2a58cf82dfe756fe092d86"></a>
typedef <a class="el" href="classilang_1_1_object.html#af23d3767cfbc8cb9312281cbfa4aae48">Object::ObjPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#adc547f597d2a58cf82dfe756fe092d86">ObjPtr</a></td></tr>
<tr class="memdesc:adc547f597d2a58cf82dfe756fe092d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for normal use of <a class="el" href="classilang_1_1_object.html" title="The basest type in the ILA structure. It can be either Ast, Instr, or InstrLvlAbs.">Object</a>. <br /></td></tr>
<tr class="separator:adc547f597d2a58cf82dfe756fe092d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e7c382e8a666b516fc761b0ce8bff8"><td class="memItemLeft" align="right" valign="top"><a id="a61e7c382e8a666b516fc761b0ce8bff8"></a>
typedef <a class="el" href="classilang_1_1_instr_seq.html#a37dd168ce5d95507eb7bf53455d79b80">InstrSeq::InstrSeqPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a61e7c382e8a666b516fc761b0ce8bff8">InstrSeqPtr</a></td></tr>
<tr class="memdesc:a61e7c382e8a666b516fc761b0ce8bff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for passing around <a class="el" href="classilang_1_1_instr_seq.html" title="Instruction Sequencing does:">InstrSeq</a>. <br /></td></tr>
<tr class="separator:a61e7c382e8a666b516fc761b0ce8bff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784e2a4ef111b96f327b76f11e86b01a"><td class="memItemLeft" align="right" valign="top"><a id="a784e2a4ef111b96f327b76f11e86b01a"></a>
typedef <a class="el" href="classilang_1_1_expr_hash.html">ExprHash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a784e2a4ef111b96f327b76f11e86b01a">Z3AdapterHash</a></td></tr>
<tr class="memdesc:a784e2a4ef111b96f327b76f11e86b01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function object for hashing <a class="el" href="classilang_1_1_expr.html" title="The class for expression, which is the basic type for variables, constraints, state update expression...">Expr</a> in generating z3 expression. <br /></td></tr>
<tr class="separator:a784e2a4ef111b96f327b76f11e86b01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a6ed2f416c0b13bf68efd21a73c67b"><td class="memItemLeft" align="right" valign="top"><a id="a42a6ed2f416c0b13bf68efd21a73c67b"></a>
typedef <a class="el" href="classilang_1_1_syn_eng_mngr.html#acaffa3e6981472cc6f0d8d5647dc1baf">SynEngMngr::SynEngMngrPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a42a6ed2f416c0b13bf68efd21a73c67b">SynEngMngrPtr</a></td></tr>
<tr class="memdesc:a42a6ed2f416c0b13bf68efd21a73c67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for normal use of <a class="el" href="classilang_1_1_syn_eng_mngr.html" title="The class for interfacing templated-based synthesis engine.">SynEngMngr</a>. <br /></td></tr>
<tr class="separator:a42a6ed2f416c0b13bf68efd21a73c67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae3529ea370d3252b9e44e20b53532e"><td class="memItemLeft" align="right" valign="top"><a id="a6ae3529ea370d3252b9e44e20b53532e"></a>
typedef <a class="el" href="classilang_1_1_expr_hash.html">ExprHash</a>&#160;</td><td class="memItemRight" valign="bottom"><b>VerilogGenHash</b></td></tr>
<tr class="separator:a6ae3529ea370d3252b9e44e20b53532e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab4dc990a0af528177f6f90b63bd208c7"><td class="memItemLeft" align="right" valign="top"><a id="ab4dc990a0af528177f6f90b63bd208c7"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab4dc990a0af528177f6f90b63bd208c7">AccessType</a> { <b>READ</b>, 
<b>WRITE</b>, 
<b>EITHER</b>
 }</td></tr>
<tr class="memdesc:ab4dc990a0af528177f6f90b63bd208c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of state read or write. <br /></td></tr>
<tr class="separator:ab4dc990a0af528177f6f90b63bd208c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb374202f0c669bea0a49b87d8dee143"><td class="memItemLeft" align="right" valign="top"><a id="aeb374202f0c669bea0a49b87d8dee143"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aeb374202f0c669bea0a49b87d8dee143">KeyVecItVal</a> { <b>END</b>, 
<b>FOUND</b>
 }</td></tr>
<tr class="memdesc:aeb374202f0c669bea0a49b87d8dee143"><td class="mdescLeft">&#160;</td><td class="mdescRight">KeyVecItVal. <br /></td></tr>
<tr class="separator:aeb374202f0c669bea0a49b87d8dee143"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a38808a9aed62a8c4a6917621c9318d6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a38808a9aed62a8c4a6917621c9318d6e">LogLevel</a> (const int &amp;lvl)</td></tr>
<tr class="memdesc:a38808a9aed62a8c4a6917621c9318d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimun log level. Log messages at or above this level will be logged. (Default: 0)  <a href="#a38808a9aed62a8c4a6917621c9318d6e">More...</a><br /></td></tr>
<tr class="separator:a38808a9aed62a8c4a6917621c9318d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b0d31076d694adcb6b1ee0a475c9dd"><td class="memItemLeft" align="right" valign="top"><a id="a04b0d31076d694adcb6b1ee0a475c9dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a04b0d31076d694adcb6b1ee0a475c9dd">LogPath</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a04b0d31076d694adcb6b1ee0a475c9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the path for log file. If specified, logfiles are written into this directory instead of the default logging directory (/tmp). <br /></td></tr>
<tr class="separator:a04b0d31076d694adcb6b1ee0a475c9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d33dbd65f2036041b06be22c830592b"><td class="memItemLeft" align="right" valign="top"><a id="a7d33dbd65f2036041b06be22c830592b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7d33dbd65f2036041b06be22c830592b">LogToErr</a> (bool to_err)</td></tr>
<tr class="memdesc:a7d33dbd65f2036041b06be22c830592b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipe log to stderr. Log messages to stderr instead of logfiles, if set to 1. <br /></td></tr>
<tr class="separator:a7d33dbd65f2036041b06be22c830592b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af596c444f0d40287ee7b91263d6ab91c"><td class="memItemLeft" align="right" valign="top"><a id="af596c444f0d40287ee7b91263d6ab91c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#af596c444f0d40287ee7b91263d6ab91c">EnableDebug</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:af596c444f0d40287ee7b91263d6ab91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a debug tag. <br /></td></tr>
<tr class="separator:af596c444f0d40287ee7b91263d6ab91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b96e3e4622bcefd2d1159766a2df3d8"><td class="memItemLeft" align="right" valign="top"><a id="a7b96e3e4622bcefd2d1159766a2df3d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7b96e3e4622bcefd2d1159766a2df3d8">DisableDebug</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:a7b96e3e4622bcefd2d1159766a2df3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a debug tag. <br /></td></tr>
<tr class="separator:a7b96e3e4622bcefd2d1159766a2df3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48e47567031b28aa1b58b82e40f60d1"><td class="memItemLeft" align="right" valign="top"><a id="ad48e47567031b28aa1b58b82e40f60d1"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad48e47567031b28aa1b58b82e40f60d1">operator-</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a)</td></tr>
<tr class="memdesc:ad48e47567031b28aa1b58b82e40f60d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic negate for bit-vectors. <br /></td></tr>
<tr class="separator:ad48e47567031b28aa1b58b82e40f60d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc8204049fd3920b75bd255c3c18f74"><td class="memItemLeft" align="right" valign="top"><a id="abdc8204049fd3920b75bd255c3c18f74"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#abdc8204049fd3920b75bd255c3c18f74">operator!</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a)</td></tr>
<tr class="memdesc:abdc8204049fd3920b75bd255c3c18f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical not for Booleans. <br /></td></tr>
<tr class="separator:abdc8204049fd3920b75bd255c3c18f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb9f43d4ffd7d0cb2061095d1986cbf"><td class="memItemLeft" align="right" valign="top"><a id="a2fb9f43d4ffd7d0cb2061095d1986cbf"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a2fb9f43d4ffd7d0cb2061095d1986cbf">operator~</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a)</td></tr>
<tr class="memdesc:a2fb9f43d4ffd7d0cb2061095d1986cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-wise complement for bit-vectors. <br /></td></tr>
<tr class="separator:a2fb9f43d4ffd7d0cb2061095d1986cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7282e60e89ef9907cc25254e9dd522"><td class="memItemLeft" align="right" valign="top"><a id="a6c7282e60e89ef9907cc25254e9dd522"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a6c7282e60e89ef9907cc25254e9dd522">operator &amp;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a6c7282e60e89ef9907cc25254e9dd522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical AND (bit-wise for bit-vectors). <br /></td></tr>
<tr class="separator:a6c7282e60e89ef9907cc25254e9dd522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4d71727922a8e7cd35bf2f9814c6f8"><td class="memItemLeft" align="right" valign="top"><a id="a7e4d71727922a8e7cd35bf2f9814c6f8"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7e4d71727922a8e7cd35bf2f9814c6f8">operator|</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a7e4d71727922a8e7cd35bf2f9814c6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical OR (bit-wise for bit-vectors). <br /></td></tr>
<tr class="separator:a7e4d71727922a8e7cd35bf2f9814c6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72e1b0d70d982d3a846436152aef3bc"><td class="memItemLeft" align="right" valign="top"><a id="ad72e1b0d70d982d3a846436152aef3bc"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad72e1b0d70d982d3a846436152aef3bc">operator^</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:ad72e1b0d70d982d3a846436152aef3bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical XOR (bit-wise for bit-vectors). <br /></td></tr>
<tr class="separator:ad72e1b0d70d982d3a846436152aef3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28e98c027804fa9307f199552870e86"><td class="memItemLeft" align="right" valign="top"><a id="ae28e98c027804fa9307f199552870e86"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ae28e98c027804fa9307f199552870e86">operator&lt;&lt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:ae28e98c027804fa9307f199552870e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left shift for bit-vectors. <br /></td></tr>
<tr class="separator:ae28e98c027804fa9307f199552870e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1848641ecc2609af5de3888328eddb8"><td class="memItemLeft" align="right" valign="top"><a id="ac1848641ecc2609af5de3888328eddb8"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ac1848641ecc2609af5de3888328eddb8">operator&gt;&gt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:ac1848641ecc2609af5de3888328eddb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic right shift for bit-vectors. <br /></td></tr>
<tr class="separator:ac1848641ecc2609af5de3888328eddb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffd757988bbf08aa6ab6395f65de46a"><td class="memItemLeft" align="right" valign="top"><a id="acffd757988bbf08aa6ab6395f65de46a"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#acffd757988bbf08aa6ab6395f65de46a">Lshr</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:acffd757988bbf08aa6ab6395f65de46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical right shift for bit-vectors. <br /></td></tr>
<tr class="separator:acffd757988bbf08aa6ab6395f65de46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9fbd2386191e9a476af6dbae9ac4d1"><td class="memItemLeft" align="right" valign="top"><a id="a4a9fbd2386191e9a476af6dbae9ac4d1"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4a9fbd2386191e9a476af6dbae9ac4d1">operator+</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a4a9fbd2386191e9a476af6dbae9ac4d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned addition for bit-vectors. <br /></td></tr>
<tr class="separator:a4a9fbd2386191e9a476af6dbae9ac4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28362d954dc9512c7292ef91df694e37"><td class="memItemLeft" align="right" valign="top"><a id="a28362d954dc9512c7292ef91df694e37"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a28362d954dc9512c7292ef91df694e37">operator-</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a28362d954dc9512c7292ef91df694e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned subtraction for bit-vectors. <br /></td></tr>
<tr class="separator:a28362d954dc9512c7292ef91df694e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879d966b396169287ed8d4e734526d22"><td class="memItemLeft" align="right" valign="top"><a id="a879d966b396169287ed8d4e734526d22"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a879d966b396169287ed8d4e734526d22">operator &amp;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const bool &amp;b)</td></tr>
<tr class="memdesc:a879d966b396169287ed8d4e734526d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical AND with Boolean constant. <br /></td></tr>
<tr class="separator:a879d966b396169287ed8d4e734526d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ad583ce28ae8f0a7acb3567d00d11a"><td class="memItemLeft" align="right" valign="top"><a id="af4ad583ce28ae8f0a7acb3567d00d11a"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#af4ad583ce28ae8f0a7acb3567d00d11a">operator|</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const bool &amp;b)</td></tr>
<tr class="memdesc:af4ad583ce28ae8f0a7acb3567d00d11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical OR with Boolean constant. <br /></td></tr>
<tr class="separator:af4ad583ce28ae8f0a7acb3567d00d11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd4e16eacbe789ffa001734f64c4247"><td class="memItemLeft" align="right" valign="top"><a id="a8bd4e16eacbe789ffa001734f64c4247"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a8bd4e16eacbe789ffa001734f64c4247">operator^</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const bool &amp;b)</td></tr>
<tr class="memdesc:a8bd4e16eacbe789ffa001734f64c4247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical XOR with Boolean constant. <br /></td></tr>
<tr class="separator:a8bd4e16eacbe789ffa001734f64c4247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce724b1e6f1d4fe10e8b4749df344f1"><td class="memItemLeft" align="right" valign="top"><a id="a9ce724b1e6f1d4fe10e8b4749df344f1"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a9ce724b1e6f1d4fe10e8b4749df344f1">operator&lt;&lt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a9ce724b1e6f1d4fe10e8b4749df344f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left shift with int constant. <br /></td></tr>
<tr class="separator:a9ce724b1e6f1d4fe10e8b4749df344f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb1919952d428702d64090f2ea81fa8"><td class="memItemLeft" align="right" valign="top"><a id="a0bb1919952d428702d64090f2ea81fa8"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a0bb1919952d428702d64090f2ea81fa8">operator&gt;&gt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a0bb1919952d428702d64090f2ea81fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic right shift with int constant. <br /></td></tr>
<tr class="separator:a0bb1919952d428702d64090f2ea81fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75467ae3bda2dbdcec1e140dada8e41"><td class="memItemLeft" align="right" valign="top"><a id="ad75467ae3bda2dbdcec1e140dada8e41"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad75467ae3bda2dbdcec1e140dada8e41">Lshr</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:ad75467ae3bda2dbdcec1e140dada8e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical right shift with int constant. <br /></td></tr>
<tr class="separator:ad75467ae3bda2dbdcec1e140dada8e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21aaed36c9ccdb21be25f46d8350430b"><td class="memItemLeft" align="right" valign="top"><a id="a21aaed36c9ccdb21be25f46d8350430b"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a21aaed36c9ccdb21be25f46d8350430b">operator+</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a21aaed36c9ccdb21be25f46d8350430b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned addition with int constant. <br /></td></tr>
<tr class="separator:a21aaed36c9ccdb21be25f46d8350430b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86888214d74c96271cda87a4f13c9dfc"><td class="memItemLeft" align="right" valign="top"><a id="a86888214d74c96271cda87a4f13c9dfc"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a86888214d74c96271cda87a4f13c9dfc">operator-</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a86888214d74c96271cda87a4f13c9dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned subtraction with int constant. <br /></td></tr>
<tr class="separator:a86888214d74c96271cda87a4f13c9dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9b38a78f3d3d10857d632479e1a1f6"><td class="memItemLeft" align="right" valign="top"><a id="acb9b38a78f3d3d10857d632479e1a1f6"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#acb9b38a78f3d3d10857d632479e1a1f6">operator==</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:acb9b38a78f3d3d10857d632479e1a1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal. <br /></td></tr>
<tr class="separator:acb9b38a78f3d3d10857d632479e1a1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c51f6da7b4a7d2e0bb4e5e06300bfb"><td class="memItemLeft" align="right" valign="top"><a id="a43c51f6da7b4a7d2e0bb4e5e06300bfb"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a43c51f6da7b4a7d2e0bb4e5e06300bfb">operator!=</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a43c51f6da7b4a7d2e0bb4e5e06300bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not equal. <br /></td></tr>
<tr class="separator:a43c51f6da7b4a7d2e0bb4e5e06300bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af297d9e26e0499970d9ec654667861db"><td class="memItemLeft" align="right" valign="top"><a id="af297d9e26e0499970d9ec654667861db"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#af297d9e26e0499970d9ec654667861db">operator&lt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:af297d9e26e0499970d9ec654667861db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed less than (bit-vectors only). <br /></td></tr>
<tr class="separator:af297d9e26e0499970d9ec654667861db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130a794f0f175d58089d16bcaabb91ae"><td class="memItemLeft" align="right" valign="top"><a id="a130a794f0f175d58089d16bcaabb91ae"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a130a794f0f175d58089d16bcaabb91ae">operator&gt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a130a794f0f175d58089d16bcaabb91ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed greater than (bit-vectors only). <br /></td></tr>
<tr class="separator:a130a794f0f175d58089d16bcaabb91ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fd64da42d7b62d90e7723fd9b99155"><td class="memItemLeft" align="right" valign="top"><a id="aa6fd64da42d7b62d90e7723fd9b99155"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aa6fd64da42d7b62d90e7723fd9b99155">operator&lt;=</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:aa6fd64da42d7b62d90e7723fd9b99155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed less than or equal to (bit-vectors only). <br /></td></tr>
<tr class="separator:aa6fd64da42d7b62d90e7723fd9b99155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3c66d75773fcf81726ef3225bf73be"><td class="memItemLeft" align="right" valign="top"><a id="a7a3c66d75773fcf81726ef3225bf73be"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a7a3c66d75773fcf81726ef3225bf73be">operator&gt;=</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a7a3c66d75773fcf81726ef3225bf73be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed greater than or equal to (bit-vectors only). <br /></td></tr>
<tr class="separator:a7a3c66d75773fcf81726ef3225bf73be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682d30cc567f56a578def19edd36f92a"><td class="memItemLeft" align="right" valign="top"><a id="a682d30cc567f56a578def19edd36f92a"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a682d30cc567f56a578def19edd36f92a">Ult</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a682d30cc567f56a578def19edd36f92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned less than (bit-vectors only). <br /></td></tr>
<tr class="separator:a682d30cc567f56a578def19edd36f92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2853af9ffe113d87fe08efa8e02b7a3"><td class="memItemLeft" align="right" valign="top"><a id="ab2853af9ffe113d87fe08efa8e02b7a3"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab2853af9ffe113d87fe08efa8e02b7a3">Ugt</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:ab2853af9ffe113d87fe08efa8e02b7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned greater than (bit-vectors only). <br /></td></tr>
<tr class="separator:ab2853af9ffe113d87fe08efa8e02b7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f01ce26f38dd0af7c1b90e26d9d42b9"><td class="memItemLeft" align="right" valign="top"><a id="a4f01ce26f38dd0af7c1b90e26d9d42b9"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4f01ce26f38dd0af7c1b90e26d9d42b9">Ule</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a4f01ce26f38dd0af7c1b90e26d9d42b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned less than or equal to (bit-vectors only). <br /></td></tr>
<tr class="separator:a4f01ce26f38dd0af7c1b90e26d9d42b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35547378b340cdd037b0c3179a4c333b"><td class="memItemLeft" align="right" valign="top"><a id="a35547378b340cdd037b0c3179a4c333b"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a35547378b340cdd037b0c3179a4c333b">Uge</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:a35547378b340cdd037b0c3179a4c333b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned greater than or equal to (bit-vectors only). <br /></td></tr>
<tr class="separator:a35547378b340cdd037b0c3179a4c333b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac570a7c815fa28fcaf3cbe903716c124"><td class="memItemLeft" align="right" valign="top"><a id="ac570a7c815fa28fcaf3cbe903716c124"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ac570a7c815fa28fcaf3cbe903716c124">operator==</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const bool &amp;b)</td></tr>
<tr class="memdesc:ac570a7c815fa28fcaf3cbe903716c124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal to Boolean constant. <br /></td></tr>
<tr class="separator:ac570a7c815fa28fcaf3cbe903716c124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5988961e07922c24fb867882884968"><td class="memItemLeft" align="right" valign="top"><a id="a0a5988961e07922c24fb867882884968"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a0a5988961e07922c24fb867882884968">operator==</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a0a5988961e07922c24fb867882884968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal to int constant. <br /></td></tr>
<tr class="separator:a0a5988961e07922c24fb867882884968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13309390fcb98b680269a31df32ee983"><td class="memItemLeft" align="right" valign="top"><a id="a13309390fcb98b680269a31df32ee983"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a13309390fcb98b680269a31df32ee983">operator!=</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a13309390fcb98b680269a31df32ee983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not equal to int constant. <br /></td></tr>
<tr class="separator:a13309390fcb98b680269a31df32ee983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb89a7f987956d5bd1d9f7233c318d6"><td class="memItemLeft" align="right" valign="top"><a id="accb89a7f987956d5bd1d9f7233c318d6"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#accb89a7f987956d5bd1d9f7233c318d6">operator&lt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:accb89a7f987956d5bd1d9f7233c318d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed less than int constant (bit-vectors only). <br /></td></tr>
<tr class="separator:accb89a7f987956d5bd1d9f7233c318d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1048b48f1599debc1925e8d171d6de9"><td class="memItemLeft" align="right" valign="top"><a id="ac1048b48f1599debc1925e8d171d6de9"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ac1048b48f1599debc1925e8d171d6de9">operator&gt;</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:ac1048b48f1599debc1925e8d171d6de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed greater than int constant (bit-vectors only). <br /></td></tr>
<tr class="separator:ac1048b48f1599debc1925e8d171d6de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa815eeb1ccb2596476fe310a286ed1c"><td class="memItemLeft" align="right" valign="top"><a id="aaa815eeb1ccb2596476fe310a286ed1c"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aaa815eeb1ccb2596476fe310a286ed1c">operator&lt;=</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:aaa815eeb1ccb2596476fe310a286ed1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed less than or equal to int constant (bit-vectors only). <br /></td></tr>
<tr class="separator:aaa815eeb1ccb2596476fe310a286ed1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603ea8347d245f1272a6a81b214d6395"><td class="memItemLeft" align="right" valign="top"><a id="a603ea8347d245f1272a6a81b214d6395"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a603ea8347d245f1272a6a81b214d6395">operator&gt;=</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a603ea8347d245f1272a6a81b214d6395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed greater than or equal to int constant (bit-vectors only). <br /></td></tr>
<tr class="separator:a603ea8347d245f1272a6a81b214d6395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db90d2df4283f54d1cd7d54a45777ea"><td class="memItemLeft" align="right" valign="top"><a id="a1db90d2df4283f54d1cd7d54a45777ea"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a1db90d2df4283f54d1cd7d54a45777ea">Ult</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a1db90d2df4283f54d1cd7d54a45777ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned less than int constant (bit-vectors only). <br /></td></tr>
<tr class="separator:a1db90d2df4283f54d1cd7d54a45777ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fdbef3ea0aac6693d4813bee367ad4"><td class="memItemLeft" align="right" valign="top"><a id="a79fdbef3ea0aac6693d4813bee367ad4"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a79fdbef3ea0aac6693d4813bee367ad4">Ugt</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a79fdbef3ea0aac6693d4813bee367ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned greater than int constant (bit-vectors only). <br /></td></tr>
<tr class="separator:a79fdbef3ea0aac6693d4813bee367ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2bc76f04057367f87de947e733a897"><td class="memItemLeft" align="right" valign="top"><a id="a5e2bc76f04057367f87de947e733a897"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a5e2bc76f04057367f87de947e733a897">Ule</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:a5e2bc76f04057367f87de947e733a897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned less than or equal to int constant (bit-vectors only). <br /></td></tr>
<tr class="separator:a5e2bc76f04057367f87de947e733a897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2e13c0f75065c992879b4599f0ec5c"><td class="memItemLeft" align="right" valign="top"><a id="abb2e13c0f75065c992879b4599f0ec5c"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#abb2e13c0f75065c992879b4599f0ec5c">Uge</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const int &amp;b)</td></tr>
<tr class="memdesc:abb2e13c0f75065c992879b4599f0ec5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned greater than or equal to int constant (bit-vectors only). <br /></td></tr>
<tr class="separator:abb2e13c0f75065c992879b4599f0ec5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4006e3000db73b20ee6f06a713d1bd"><td class="memItemLeft" align="right" valign="top"><a id="a1f4006e3000db73b20ee6f06a713d1bd"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a1f4006e3000db73b20ee6f06a713d1bd">Load</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;mem, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;addr)</td></tr>
<tr class="memdesc:a1f4006e3000db73b20ee6f06a713d1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load from memory. <br /></td></tr>
<tr class="separator:a1f4006e3000db73b20ee6f06a713d1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32b36b718a94a19184be0eaa66e5774"><td class="memItemLeft" align="right" valign="top"><a id="ad32b36b718a94a19184be0eaa66e5774"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad32b36b718a94a19184be0eaa66e5774">Store</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;mem, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;addr, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;data)</td></tr>
<tr class="memdesc:ad32b36b718a94a19184be0eaa66e5774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store to memory. <br /></td></tr>
<tr class="separator:ad32b36b718a94a19184be0eaa66e5774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa9ea7950a14ee2aeee819185b552b5"><td class="memItemLeft" align="right" valign="top"><a id="a3aa9ea7950a14ee2aeee819185b552b5"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a3aa9ea7950a14ee2aeee819185b552b5">Load</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;mem, const int &amp;addr)</td></tr>
<tr class="memdesc:a3aa9ea7950a14ee2aeee819185b552b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load from memory with constant address. <br /></td></tr>
<tr class="separator:a3aa9ea7950a14ee2aeee819185b552b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9db91d7f135f2abb8b3aee379850c01"><td class="memItemLeft" align="right" valign="top"><a id="ab9db91d7f135f2abb8b3aee379850c01"></a>
<a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab9db91d7f135f2abb8b3aee379850c01">Store</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;mem, const int &amp;addr, const int &amp;data)</td></tr>
<tr class="memdesc:ab9db91d7f135f2abb8b3aee379850c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store to memory at constant address and data. <br /></td></tr>
<tr class="separator:ab9db91d7f135f2abb8b3aee379850c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74b423140c9b8a60e1bac56e90ba175"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aa74b423140c9b8a60e1bac56e90ba175">Concat</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;msbv, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;lsbv)</td></tr>
<tr class="memdesc:aa74b423140c9b8a60e1bac56e90ba175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two bit-vectors.  <a href="#aa74b423140c9b8a60e1bac56e90ba175">More...</a><br /></td></tr>
<tr class="separator:aa74b423140c9b8a60e1bac56e90ba175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73a95aa5988d50567c5ff6fe53de913"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab73a95aa5988d50567c5ff6fe53de913">Extract</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;bv, const int &amp;hi, const int &amp;lo)</td></tr>
<tr class="memdesc:ab73a95aa5988d50567c5ff6fe53de913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract bit-field in the bit-vector.  <a href="#ab73a95aa5988d50567c5ff6fe53de913">More...</a><br /></td></tr>
<tr class="separator:ab73a95aa5988d50567c5ff6fe53de913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a510ed3c6bbe8cb314bdfb8d664283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a28a510ed3c6bbe8cb314bdfb8d664283">SelectBit</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;bv, const int &amp;idx)</td></tr>
<tr class="memdesc:a28a510ed3c6bbe8cb314bdfb8d664283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract single bit in the bit-vector.  <a href="#a28a510ed3c6bbe8cb314bdfb8d664283">More...</a><br /></td></tr>
<tr class="separator:a28a510ed3c6bbe8cb314bdfb8d664283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad992886a38803601f88f987b174f4c34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad992886a38803601f88f987b174f4c34">ZExt</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;bv, const int &amp;length)</td></tr>
<tr class="memdesc:ad992886a38803601f88f987b174f4c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-extend the bit-vector to the specified length.  <a href="#ad992886a38803601f88f987b174f4c34">More...</a><br /></td></tr>
<tr class="separator:ad992886a38803601f88f987b174f4c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a2da11f53d77bc38c204c87f6eecda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ae0a2da11f53d77bc38c204c87f6eecda">SExt</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;bv, const int &amp;length)</td></tr>
<tr class="memdesc:ae0a2da11f53d77bc38c204c87f6eecda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extend the bit-vector to the specified length.  <a href="#ae0a2da11f53d77bc38c204c87f6eecda">More...</a><br /></td></tr>
<tr class="separator:ae0a2da11f53d77bc38c204c87f6eecda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717385221eb8322e7b19096ba48d2516"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a717385221eb8322e7b19096ba48d2516">Imply</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;ante, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;cons)</td></tr>
<tr class="memdesc:a717385221eb8322e7b19096ba48d2516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical imply for Booleans.  <a href="#a717385221eb8322e7b19096ba48d2516">More...</a><br /></td></tr>
<tr class="separator:a717385221eb8322e7b19096ba48d2516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63ed74adc72075df524ec933146f0f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab63ed74adc72075df524ec933146f0f3">Ite</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;cond, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;t, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;f)</td></tr>
<tr class="memdesc:ab63ed74adc72075df524ec933146f0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If-then-else on the Boolean condition.  <a href="#ab63ed74adc72075df524ec933146f0f3">More...</a><br /></td></tr>
<tr class="separator:ab63ed74adc72075df524ec933146f0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b370cb62e6bb2a4abba9b9f482ff6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a41b370cb62e6bb2a4abba9b9f482ff6f">BoolConst</a> (bool bool_val)</td></tr>
<tr class="memdesc:a41b370cb62e6bb2a4abba9b9f482ff6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Boolean constant.  <a href="#a41b370cb62e6bb2a4abba9b9f482ff6f">More...</a><br /></td></tr>
<tr class="separator:a41b370cb62e6bb2a4abba9b9f482ff6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c81eb12aece5b37849917b2dee95695"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a2c81eb12aece5b37849917b2dee95695">BvConst</a> (const int &amp;bv_val, const int &amp;bit_width)</td></tr>
<tr class="memdesc:a2c81eb12aece5b37849917b2dee95695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a bit-vector constant.  <a href="#a2c81eb12aece5b37849917b2dee95695">More...</a><br /></td></tr>
<tr class="separator:a2c81eb12aece5b37849917b2dee95695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aabcae2083096742642384a583eb06f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4aabcae2083096742642384a583eb06f">MemConst</a> (const int &amp;def_val, const std::map&lt; int, int &gt; &amp;vals, const int &amp;addr_width, const int &amp;data_width)</td></tr>
<tr class="memdesc:a4aabcae2083096742642384a583eb06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a memory constant.  <a href="#a4aabcae2083096742642384a583eb06f">More...</a><br /></td></tr>
<tr class="separator:a4aabcae2083096742642384a583eb06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc42fabe7c53eadf8db66da979cd156"><td class="memItemLeft" align="right" valign="top"><a id="aafc42fabe7c53eadf8db66da979cd156"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#aafc42fabe7c53eadf8db66da979cd156">TopEqual</a> (const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;a, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;b)</td></tr>
<tr class="memdesc:aafc42fabe7c53eadf8db66da979cd156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topologically equivalent. <br /></td></tr>
<tr class="separator:aafc42fabe7c53eadf8db66da979cd156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bcc3ec35bb95561155203ab61e2e0d"><td class="memItemLeft" align="right" valign="top"><a id="ab9bcc3ec35bb95561155203ab61e2e0d"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ab9bcc3ec35bb95561155203ab61e2e0d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;expr)</td></tr>
<tr class="memdesc:ab9bcc3ec35bb95561155203ab61e2e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the <a class="el" href="classilang_1_1_expr_ref.html" title="The wrapper of Expr (e.g. state var, var relation, constant, etc).">ExprRef</a>. <br /></td></tr>
<tr class="separator:ab9bcc3ec35bb95561155203ab61e2e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a7e5decaea56c186a7576ddf30379b"><td class="memItemLeft" align="right" valign="top"><a id="a36a7e5decaea56c186a7576ddf30379b"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a36a7e5decaea56c186a7576ddf30379b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classilang_1_1_instr_ref.html">InstrRef</a> &amp;instr)</td></tr>
<tr class="memdesc:a36a7e5decaea56c186a7576ddf30379b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the Instruction. <br /></td></tr>
<tr class="separator:a36a7e5decaea56c186a7576ddf30379b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1bf9ab1a26dcdd7ac71b99181c96ac"><td class="memItemLeft" align="right" valign="top"><a id="a6a1bf9ab1a26dcdd7ac71b99181c96ac"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a6a1bf9ab1a26dcdd7ac71b99181c96ac">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classilang_1_1_ila.html">Ila</a> &amp;ila)</td></tr>
<tr class="memdesc:a6a1bf9ab1a26dcdd7ac71b99181c96ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the ILA. <br /></td></tr>
<tr class="separator:a6a1bf9ab1a26dcdd7ac71b99181c96ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71519439e68ee7fa1eac03efd983a75d"><td class="memItemLeft" align="right" valign="top"><a id="a71519439e68ee7fa1eac03efd983a75d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TestJsonParse</b> ()</td></tr>
<tr class="separator:a71519439e68ee7fa1eac03efd983a75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f0dd2c19f74d7e96efc740fba76c6a"><td class="memItemLeft" align="right" valign="top">z3::expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a75f0dd2c19f74d7e96efc740fba76c6a">Z3Implies</a> (const z3::expr &amp;a, const z3::expr &amp;b)</td></tr>
<tr class="memdesc:a75f0dd2c19f74d7e96efc740fba76c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is to deal with forall (if does not exist, it should be true also)  <a href="#a75f0dd2c19f74d7e96efc740fba76c6a">More...</a><br /></td></tr>
<tr class="separator:a75f0dd2c19f74d7e96efc740fba76c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181bcd7690eed0466a301469995543a4"><td class="memItemLeft" align="right" valign="top"><a id="a181bcd7690eed0466a301469995543a4"></a>
z3::expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a181bcd7690eed0466a301469995543a4">Z3And</a> (const z3::expr &amp;a, const z3::expr &amp;b)</td></tr>
<tr class="memdesc:a181bcd7690eed0466a301469995543a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is just a shortcut to be used for generated axiom. <br /></td></tr>
<tr class="separator:a181bcd7690eed0466a301469995543a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5002dc8078f121ff03b282d1637b4c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#ad5002dc8078f121ff03b282d1637b4c0">SetLogLevel</a> (const int &amp;lvl)</td></tr>
<tr class="memdesc:ad5002dc8078f121ff03b282d1637b4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimun log level. Log messages at or above this level will be logged. (Default: 0)  <a href="#ad5002dc8078f121ff03b282d1637b4c0">More...</a><br /></td></tr>
<tr class="separator:ad5002dc8078f121ff03b282d1637b4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad694e631ce9de3140f3d3991f87728"><td class="memItemLeft" align="right" valign="top"><a id="a4ad694e631ce9de3140f3d3991f87728"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a4ad694e631ce9de3140f3d3991f87728">SetLogPath</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a4ad694e631ce9de3140f3d3991f87728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the path for log file. If specified, logfiles are written into this directory instead of the default logging directory (/tmp). <br /></td></tr>
<tr class="separator:a4ad694e631ce9de3140f3d3991f87728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297a8bf42d97a385aa18916321c6bce6"><td class="memItemLeft" align="right" valign="top"><a id="a297a8bf42d97a385aa18916321c6bce6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a297a8bf42d97a385aa18916321c6bce6">SetToStdErr</a> (const int &amp;to_err)</td></tr>
<tr class="memdesc:a297a8bf42d97a385aa18916321c6bce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipe log to stderr. Log messages to stderr instead of logfiles, if set to 1. <br /></td></tr>
<tr class="separator:a297a8bf42d97a385aa18916321c6bce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0991fc567e0acf208e32077bfa58c0e8"><td class="memItemLeft" align="right" valign="top"><a id="a0991fc567e0acf208e32077bfa58c0e8"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a0991fc567e0acf208e32077bfa58c0e8">StrToUpper</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a0991fc567e0acf208e32077bfa58c0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform basic string to upper case. <br /></td></tr>
<tr class="separator:a0991fc567e0acf208e32077bfa58c0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cdb1960acea845bdad15ad077fb1e7"><td class="memItemLeft" align="right" valign="top"><a id="a44cdb1960acea845bdad15ad077fb1e7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a44cdb1960acea845bdad15ad077fb1e7">StrToLower</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a44cdb1960acea845bdad15ad077fb1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform basic string to lower case. <br /></td></tr>
<tr class="separator:a44cdb1960acea845bdad15ad077fb1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cf3586b9c4507e7a8ba88bb181b158"><td class="memItemLeft" align="right" valign="top"><a id="a10cf3586b9c4507e7a8ba88bb181b158"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a10cf3586b9c4507e7a8ba88bb181b158">StrToBool</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a10cf3586b9c4507e7a8ba88bb181b158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if string is "true" or "True". <br /></td></tr>
<tr class="separator:a10cf3586b9c4507e7a8ba88bb181b158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be0ce405f6e9487afc441d2d2200b00"><td class="memItemLeft" align="right" valign="top"><a id="a6be0ce405f6e9487afc441d2d2200b00"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceilang.html#a6be0ce405f6e9487afc441d2d2200b00">StrToInt</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a6be0ce405f6e9487afc441d2d2200b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value represented in the string, e.g. "10". <br /></td></tr>
<tr class="separator:a6be0ce405f6e9487afc441d2d2200b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f8e2034f6578c089d6ceb5600cab7d"><td class="memItemLeft" align="right" valign="top"><a id="a01f8e2034f6578c089d6ceb5600cab7d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TestParseVerilog</b> ()</td></tr>
<tr class="separator:a01f8e2034f6578c089d6ceb5600cab7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bc7ea62eac3a9dd0dfcc0337abe99d"><td class="memItemLeft" align="right" valign="top"><a id="a80bc7ea62eac3a9dd0dfcc0337abe99d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>TestParseVerilogFrom</b> (std::FILE *fp)</td></tr>
<tr class="separator:a80bc7ea62eac3a9dd0dfcc0337abe99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p class="">Defines the core data structure and APIs for constructing and storing ILA. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a41b370cb62e6bb2a4abba9b9f482ff6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b370cb62e6bb2a4abba9b9f482ff6f">&#9670;&nbsp;</a></span>BoolConst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::BoolConst </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bool_val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a Boolean constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bool_val</td><td>value of the Boolean constant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c81eb12aece5b37849917b2dee95695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c81eb12aece5b37849917b2dee95695">&#9670;&nbsp;</a></span>BvConst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::BvConst </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>bv_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>bit_width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a bit-vector constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bv_val</td><td>value of the bit-vector constant. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_width</td><td>data bit-width. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa74b423140c9b8a60e1bac56e90ba175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74b423140c9b8a60e1bac56e90ba175">&#9670;&nbsp;</a></span>Concat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::Concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>msbv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>lsbv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two bit-vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msbv</td><td>bit-vector on the more-significant side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lsbv</td><td>bit-vector on the less-significant side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab73a95aa5988d50567c5ff6fe53de913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73a95aa5988d50567c5ff6fe53de913">&#9670;&nbsp;</a></span>Extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::Extract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>bv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>lo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract bit-field in the bit-vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bv</td><td>source bit-vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hi</td><td>the index of the most-significant bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lo</td><td>the index of the least-significant bit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a717385221eb8322e7b19096ba48d2516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717385221eb8322e7b19096ba48d2516">&#9670;&nbsp;</a></span>Imply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::Imply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>ante</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logical imply for Booleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ante</td><td>antecedent for the operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cons</td><td>consequent for the operator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab63ed74adc72075df524ec933146f0f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63ed74adc72075df524ec933146f0f3">&#9670;&nbsp;</a></span>Ite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::Ite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If-then-else on the Boolean condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cond</td><td>Boolean type condition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Expression to take when the condition is true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Expression to take when the condition is false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38808a9aed62a8c4a6917621c9318d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38808a9aed62a8c4a6917621c9318d6e">&#9670;&nbsp;</a></span>LogLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ilang::LogLevel </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>lvl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minimun log level. Log messages at or above this level will be logged. (Default: 0) </p>
<ul>
<li>INFO: level 0</li>
<li>WARNING: level 1</li>
<li>ERROR: level 2</li>
<li>FATAL: level 3 </li>
</ul>

</div>
</div>
<a id="a4aabcae2083096742642384a583eb06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aabcae2083096742642384a583eb06f">&#9670;&nbsp;</a></span>MemConst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::MemConst </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>def_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; int, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>addr_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>data_width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a memory constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">def_val</td><td>default value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vals</td><td>non-default address-data mapping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_width</td><td>address bit-width. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_width</td><td>data bit-width. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28a510ed3c6bbe8cb314bdfb8d664283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a510ed3c6bbe8cb314bdfb8d664283">&#9670;&nbsp;</a></span>SelectBit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::SelectBit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>bv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract single bit in the bit-vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bv</td><td>source bit-vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>the index of the selected bit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5002dc8078f121ff03b282d1637b4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5002dc8078f121ff03b282d1637b4c0">&#9670;&nbsp;</a></span>SetLogLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ilang::SetLogLevel </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>lvl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minimun log level. Log messages at or above this level will be logged. (Default: 0) </p>
<ul>
<li>INFO: level 0</li>
<li>WARNING: level 1</li>
<li>ERROR: level 2</li>
<li>FATAL: level 3 </li>
</ul>

</div>
</div>
<a id="ae0a2da11f53d77bc38c204c87f6eecda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a2da11f53d77bc38c204c87f6eecda">&#9670;&nbsp;</a></span>SExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::SExt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>bv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sign-extend the bit-vector to the specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bv</td><td>source bit-vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>bit-width of the extended (result) bit-vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75f0dd2c19f74d7e96efc740fba76c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f0dd2c19f74d7e96efc740fba76c6a">&#9670;&nbsp;</a></span>Z3Implies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">z3::expr ilang::Z3Implies </td>
          <td>(</td>
          <td class="paramtype">const z3::expr &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const z3::expr &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is to deal with forall (if does not exist, it should be true also) </p>
<p class="">This is to apply to exists, (if does not exist, it should be false) This is just a shortcut to be used for generated axiom </p>

</div>
</div>
<a id="ad992886a38803601f88f987b174f4c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad992886a38803601f88f987b174f4c34">&#9670;&nbsp;</a></span>ZExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> ilang::ZExt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classilang_1_1_expr_ref.html">ExprRef</a> &amp;&#160;</td>
          <td class="paramname"><em>bv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zero-extend the bit-vector to the specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bv</td><td>source bit-vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>bit-width of the extended (result) bit-vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
