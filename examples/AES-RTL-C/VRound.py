import ila
import R1

innerTable = [ 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 ]

xStable  = [0xc6, 0xf8, 0xee, 0xf6, 0xff, 0xd6, 0xde, 0x91, 0x60, 0x02, 0xce, 0x56, 0xe7, 0xb5, 0x4d, 0xec, 0x8f, 0x1f, 0x89, 0xfa, 0xef, 0xb2, 0x8e, 0xfb, 0x41, 0xb3, 0x5f, 0x45, 0x23, 0x53, 0xe4, 0x9b, 0x75, 0xe1, 0x3d, 0x4c, 0x6c, 0x7e, 0xf5, 0x83, 0x68, 0x51, 0xd1, 0xf9, 0xe2, 0xab, 0x62, 0x2a, 0x08, 0x95, 0x46, 0x9d, 0x30, 0x37, 0x0a, 0x2f, 0x0e, 0x24, 0x1b, 0xdf, 0xcd, 0x4e, 0x7f, 0xea, 0x12, 0x1d, 0x58, 0x34, 0x36, 0xdc, 0xb4, 0x5b, 0xa4, 0x76, 0xb7, 0x7d, 0x52, 0xdd, 0x5e, 0x13, 0xa6, 0xb9, 0x00, 0xc1, 0x40, 0xe3, 0x79, 0xb6, 0xd4, 0x8d, 0x67, 0x72, 0x94, 0x98, 0xb0, 0x85, 0xbb, 0xc5, 0x4f, 0xed, 0x86, 0x9a, 0x66, 0x11, 0x8a, 0xe9, 0x04, 0xfe, 0xa0, 0x78, 0x25, 0x4b, 0xa2, 0x5d, 0x80, 0x05, 0x3f, 0x21, 0x70, 0xf1, 0x63, 0x77, 0xaf, 0x42, 0x20, 0xe5, 0xfd, 0xbf, 0x81, 0x18, 0x26, 0xc3, 0xbe, 0x35, 0x88, 0x2e, 0x93, 0x55, 0xfc, 0x7a, 0xc8, 0xba, 0x32, 0xe6, 0xc0, 0x19, 0x9e, 0xa3, 0x44, 0x54, 0x3b, 0x0b, 0x8c, 0xc7, 0x6b, 0x28, 0xa7, 0xbc, 0x16, 0xad, 0xdb, 0x64, 0x74, 0x14, 0x92, 0x0c, 0x48, 0xb8, 0x9f, 0xbd, 0x43, 0xc4, 0x39, 0x31, 0xd3, 0xf2, 0xd5, 0x8b, 0x6e, 0xda, 0x01, 0xb1, 0x9c, 0x49, 0xd8, 0xac, 0xf3, 0xcf, 0xca, 0xf4, 0x47, 0x10, 0x6f, 0xf0, 0x4a, 0x5c, 0x38, 0x57, 0x73, 0x97, 0xcb, 0xa1, 0xe8, 0x3e, 0x96, 0x61, 0x0d, 0x0f, 0xe0, 0x7c, 0x71, 0xcc, 0x90, 0x06, 0xf7, 0x1c, 0xc2, 0x6a, 0xae, 0x69, 0x17, 0x99, 0x3a, 0x27, 0xd9, 0xeb, 0x2b, 0x22, 0xd2, 0xa9, 0x07, 0x33, 0x2d, 0x3c, 0x15, 0xc9, 0x87, 0xaa, 0x50, 0xa5, 0x03, 0x59, 0x09, 0x1a, 0x65, 0xd7, 0x84, 0xd0, 0x82, 0x29, 0x5a, 0x1e, 0x7b, 0xa8, 0x6d, 0x2c]

def fulltable(inp):
    expr = ila.const(0,8)
    for i in range(256):
        val = ila.const(innerTable[i],8)
        expr = ila.ite(inp == i, val, expr )
    return expr
def xSt(inp):
    expr = ila.const(0,8)
    for i in range(256):
        val = ila.const(xStable[i],8)
        expr = ila.ite(inp == i, val, expr )
    return expr

def Lto128(L):
    return ila.concat( [L[0],L[1],L[2],L[3]] )

def slice128to32(bv):
    rL = [ bv[32*idx+31:32*idx] for idx in range(3,-1,-1) ]
    return rL

def slice32to8(bv):
    rL = [ bv[8*idx+7:8*idx] for idx in range(3,-1,-1) ]
    return rL

def cat(L):
    return ila.concat(L)



def S4(inp,tab): # in bv32
    return cat( [ S(inp[31:24], tab), S(inp[23:16], tab), S(inp[15:8], tab), S(inp[7:0], tab) ] )

def S(inp,tab): # in bv8 out bv8
    return fulltable(inp)

def xS(inp,tab):
    return xSt(inp)

def expand_key_128(inp,rcon,tab): # k1 k0b
    # inp: 128 ,rcon 8, out 1,2:128

    [k0,k1,k2,k3] = slice128to32(inp)
    v0 = ila.concat([k0[31:24] ^ rcon , k0[23:0]])
    v1 = v0 ^ k1
    v2 = v1 ^ k2
    v3 = v2 ^ k3

    [k0a,k1a,k2a,k3a] = [v0,v1,v2,v3]
    k4a = S4 ( cat([k3[23:0], k3[31:24] ]), tab )

    [k0b,k1b,k2b,k3b] = [k0a^k4a, k1a^k4a, k2a^k4a, k3a^k4a]

    return [k0b,k1b,k2b,k3b]

def T(inp, tab) : # in 8, out 32
    sl0 = S( inp, tab)
    sl1 = sl0
    sl3 = xS( inp, tab)
    sl2 = sl1 ^ sl3
    return [sl0,sl1,sl2,sl3]

def table_lookup(state, tab): # input 32, output [p0,p1,p2,p3]
    [b0,b1,b2,b3] = slice32to8(state)
    [rl0,rl1,rl2,rl3] = T(b0, tab)
    p0 = cat( [rl3,rl0,rl1,rl2] )

    [rl0,rl1,rl2,rl3] = T(b1, tab)
    p1 = cat( [rl2,rl3,rl0,rl1] )
    [rl0,rl1,rl2,rl3] = T(b2, tab)
    p2 = cat( [rl1,rl2,rl3,rl0] )
    [rl0,rl1,rl2,rl3] = T(b3, tab)
    p3 = cat( [rl0,rl1,rl2,rl3] )
    return [p0,p1,p2,p3]


def buildTemplateVR1(aes):
    # 

    key0 = aes.getreg('in_key0')
    key1 = aes.getreg('in_key1')
    key2 = aes.getreg('in_key2')
    key3 = aes.getreg('in_key3')
    state0 = aes.getreg('state0')
    state1 = aes.getreg('state1')
    state2 = aes.getreg('state2')
    state3 = aes.getreg('state3')

    debug = aes.reg('vdb',32)
    def _print(n):
        aes.set_next('vdb',n)

    i = aes.getreg('i')

    rsT = aes.reg('encr1',128)
    rsK = aes.reg('keyr1',128)
    #vtable = aes.mem('vtable', 8, 8)
    #tab = fulltable(vtable)
    tab = None

    # assuming the above are given in little-endian


    [state0,state1,state2,state3] = [state0^key0,state1^key1,state2^key2,state3^key3]  # pre-round
    k0t = Lto128([key0,key1,key2,key3])

    # inside one round
    [k0,k1,k2,k3] = expand_key_128(k0t, ila.const(1,8) ,tab)
    [p00,p01,p02,p03] = table_lookup(state0,tab) 
    [p10,p11,p12,p13] = table_lookup(state1,tab) 
    [p20,p21,p22,p23] = table_lookup(state2,tab) ; tab = _print
    [p30,p31,p32,p33] = table_lookup(state3,tab) ; tab = None

    z0 = p00 ^ p11 ^ p22 ^ p33 ^ k0;

    z1 = p03 ^ p10 ^ p21 ^ p32 ^ k1;
    z2 = p02 ^ p13 ^ p20 ^ p31 ^ k2;
    z3 = p01 ^ p12 ^ p23 ^ p30 ^ k3;

    _print(z3)

    state_out = cat([z0,z1,z2,z3])

    aes.set_next('encr1', state_out)
    aes.set_next('keyr1', cat([k0,k1,k2,k3]))
    return aes


def selfModel():
    aes = ila.Abstraction('aesr')
    key0 = aes.reg('in_key0',32)
    key1 = aes.reg('in_key1',32)
    key2 = aes.reg('in_key2',32)
    key3 = aes.reg('in_key3',32)

    state0 = aes.reg('state0',32)
    state1 = aes.reg('state1',32)
    state2 = aes.reg('state2',32)
    state3 = aes.reg('state3',32)

    i = aes.reg('i',4)
    return aes

def buildTwoModels():
    aes = R1.buildTemplate()
    #aes = selfModel()
    aesR2 = buildTemplateVR1(aes)
    return aesR2

def checkEQ(aes):
    roundkeyA0 = aes.getreg('in_key0')
    roundkeyA1 = aes.getreg('in_key1')
    roundkeyA2 = aes.getreg('in_key2')
    roundkeyA3 = aes.getreg('in_key3')
    roundKeyB  = aes.getreg('keyr1')


    roundENCA0 = aes.getreg('state0')
    roundENCA1 = aes.getreg('state1')
    roundENCA2 = aes.getreg('state2')
    roundENCA3 = aes.getreg('state3')
    roundENCB  = aes.getreg('encr1')

    a1 = cat([roundkeyA0,roundkeyA1,roundkeyA2,roundkeyA3]) == roundKeyB
    a2 = cat([roundENCA0,roundENCA1,roundENCA2,roundENCA3]) == roundENCB
    print 'Round Key EQ:',
    print 'Pending...'
    print aes.bmcInit(assertion = a1, bound = 1, init = True)
    print 'Round Enc EQ:',
    print 'Pending...'
    print aes.bmcInit(assertion = a2, bound = 1, init = True)

if __name__ == '__main__':
    ila.setloglevel(3,"")
    ila.enablelog("BMCResult")
    
    aesR = buildTwoModels()
    print 'built Complete.'
    checkEQ(aesR)
    print 'prove Complete.'
